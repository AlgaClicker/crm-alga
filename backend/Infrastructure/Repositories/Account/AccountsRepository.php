<?php

namespace Infrastructure\Repositories\Account;
use Doctrine\ORM\EntityManager;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Request;
use Infrastructure\Repositories\AbstractRepository;
use Domain\Contracts\Repository\AccountsRepositoryContracts;
use Domain\Entities\Subscriber\Account;
use Domain\Entities\Subscriber\AccountTokens;
use Illuminate\Support\Facades\Hash;
use Domain\Contracts\Repository\AccountOptionsContract;
use Domain\Contracts\Repository\AccountTokensRepositoryContract;


/**
 * CommentsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AccountsRepository extends AbstractRepository implements AccountsRepositoryContracts
{
    protected OptionsRepository $options;
    private AccountTokensRepositoryContract $tokensRepository;
    private $tokenNameEntity;

    public function __construct(
        EntityManager $em,
        Account $entity,
        OptionsRepository $options,
        AccountTokensRepositoryContract $tokensRepository
    ){
        $this->options = $options;
        $this->entity = $entity;
        $this->tokensRepository = $tokensRepository;
        $this->tokenNameEntity = get_class(new AccountTokens());
        //$this->tokensRepository=$this->em->getRepository($this->tokenNameEntity);
        parent::__construct($em,  $entity);
    }

    public function login($username,$password,$headers='')
    {
        $account = $this->findBy(['username'=>$username,'delete'=>false]);
         if (!$account) {
             $account = $this->findBy(['email'=>$username,'delete'=>false]);
         }

        if (!$account) {
            return null;
        }

        if (Hash::check($password, $account->getPassword())) {

            return $account;
        }

        return false;
    }

    public function heckToken($jwtToken)
    {


        //$token = $this->tokensRepository->findAll();
        if ($this->tokensRepository->checkToken($jwtToken)){
            return $this->tokensRepository->checkToken($jwtToken)->getAccount();
        }
        /*
                if ( $token) {
                    return $token->getAccount();
                }
                */
        if ($this->findBy(['token'=>$jwtToken,'delete'=>false])) {
            return $this->findBy(['token'=>$jwtToken,'delete'=>false]);
        }

    }

    public function checkToken($token) {


        if ($this->em->getRepository($this->tokenNameEntity)->findOneBy(['token'=>$token])) {
            return $this->em->getRepository($this->tokenNameEntity)->findOneBy(['token'=>$token])->getAccount();
        } else {
            return false;
        }
    }

    public function setToken(Account $account, $token, $headers) {

        $config = Config::get('jwt');
        $acountToken = new AccountTokens();
        $account = $this->findOne($account);
        $account->setToken($token);
        $acountToken->setAccount($account);
        $acountToken->setToken($token);
        $acountToken->setCreatedAt(new \DateTimeImmutable('now'));
        $acountToken->setClient(Request::getProtocolVersion());
        if (array_key_exists('refresh_ttl',$config)) {
            $acountToken->setExpiresIn($config['refresh_ttl']);
        } else  {
            $acountToken->setExpiresIn('8200');
        }

        if ($headers) {
            if (array_key_exists('user-agent',$headers)) {
                $acountToken->setDevice($headers['user-agent'][0]);
            }
            $acountToken->setHost(Request::getClientIp());
        }
        $this->em->persist($acountToken);
        $this->em->persist($account);
        $this->em->flush();
        //$this->em->flush($acountToken);;
        //dd($acountToken);



        //$token = $this->tokensRepository->newToken($account, $token,$headers);
        return $account;
    }

    public function optionsGet($idAccount): array
    {
        $account = parent::findOne($idAccount);
        return $this->options->findAllBy(['account'=>$account]);
    }

    public function cleanOldTokens() {
        return $this->tokensRepository->cleanOldTokens();
    }

    public function optionsSet($idAccount,$arrKeyValue) {
        $account = parent::findOne($idAccount);
        foreach ($arrKeyValue as $key=>$val) {
            $option = $this->options->findBy(['key'=>$key, 'account'=>$account]);
            if ($option) {
                $data['key'] = $key;
                $data['val'] = $val;
                $this->options->update($option,$data);
            } else {
                $data['key'] = $key;
                $data['val'] = $val;
                $data['account'] = $account->getId();
                $data['active'] = true;
                $this->options->create($data);
            }

        }
        return $this->optionsGet($account->getId());
    }

    public function registrationConfirm($hash_confirm)
    {
        $account = $this->findOneBy(['token'=>$hash_confirm]);
        if (!$account) {
            return null;
        }
        $company = $account->getCompany();
        if ($company->getActive() === true) {
           // abort("409","Компания Активирована");
        }
        $company->setActive(true);
        $this->em->persist($company);
        $this->em->flush();
        return $company;
    }

}
