<?php

namespace Infrastructure\Repositories\Document;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\QueryBuilder;
use Doctrine\ORM\Tools\Pagination\Paginator;
use Domain\Contracts\Repository\Document\ContractsRepositoryContract;
use Domain\Entities\Business\Document\Contracts;
use Infrastructure\Repositories\AbstractRepository;
use Domain\Entities\Business\Objects\Specification;
use Infrastructure\Repositories\Services\FileRepository;
/**
 * CommentsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ContractsRepository extends AbstractRepository implements ContractsRepositoryContract
{

    private FileRepository $fileRepository;
    public function __construct(EntityManager $em, Contracts $entity,FileRepository $fileRepository)
    {

        $this->fileRepository = $fileRepository;
        parent::__construct($em, $entity);
    }

    public function getListContracts($options=[]) {
        $options = $this->parseOptions($options);

        if (array_key_exists('limit',$options['pagginate'])) {
            $limit = $options['pagginate']['limit'];
        } else {
            $limit = $this->getDefaultLimit();
        }
        $options['pagginate']['recordLimit'] = $limit;

        $qb = $this->em->createQueryBuilder();
        $qb->select('thisEntity,spec')->from(get_class($this->entity),'thisEntity');
        $qb->leftJoin(Specification::class,'spec');

        $dqlScript = $this->filterByQuery($options['filter'],$options['orderBy']);

        $query = $this->em->createQuery($dqlScript);

        return $this->_options($query,$options);
    }

    public function getListWorkContracts($options=[]) {
        $options = $this->parseOptions($options);

        if (array_key_exists('limit',$options['pagginate'])) {
            $limit = $options['pagginate']['limit'];
        } else {
            $limit = $this->getDefaultLimit();
        }
        $options['pagginate']['recordLimit'] = $limit;

        $qb = $this->em->createQueryBuilder();
        $qb->select('thisEntity,spec')->from(get_class($this->entity),'thisEntity');
        $qb->leftJoin(Specification::class,'spec');
        $qb->where($qb->expr()->eq('thisEntity.type','construction'));
        $dqlScript = $this->filterByQuery($options['filter'],$options['orderBy']);
        $dqlScript .= " AND thisEntity.type = 'construction'";

        $query = $this->em->createQuery($dqlScript);

        return $this->_options($query,$options);
    }

    public function getListSupplyContracts($options=[]) {
        $options = $this->parseOptions($options);

        if (array_key_exists('limit',$options['pagginate'])) {
            $limit = $options['pagginate']['limit'];
        } else {
            $limit = $this->getDefaultLimit();
        }
        $options['pagginate']['recordLimit'] = $limit;
        $options['filter'] = array_merge($options['filter'],['type'=>'supply']);
        $dqlScript = $this->filterByQuery($options['filter'],$options['orderBy']);

        $query = $this->em->createQuery($dqlScript);
        return $this->_options($query,$options);
    }


    private function _options( $query,$options=[]) {

        $pagginate=[];
        $orderBy=[];
        if ($options && array_key_exists('pagginate',$options)) {
            $pagginate = $options['pagginate'];
        }
        if (!array_key_exists('filter',$options)) {
            $options['filter'] = [];
        }

        if ($options && array_key_exists('orderBy',$options)) {
            $orderBy = $this->checkAttr($options['orderBy']);

        }

        if ($options &&array_key_exists('page',$pagginate)) {
            $page = $pagginate['page'];
        } else {
            $page = 1;
        }

        if ($options && array_key_exists('limit',$pagginate)) {
            $limit = $pagginate['limit'];
        } else {
            $limit = $this->getDefaultLimit();
        }

        $companyId = auth()->user()->getCompany();
        //$query->setParameter('company', $companyId);


        $paginator = new Paginator($query, $fetchJoinCollection = false);
        $count = count($paginator);
        $pages = ceil($count/$limit);

        $options = [
            'pagginate'=>[
                'pages'=>$pages,
                'limit'=>$limit,
                'page'=>$page,
                'count'=>$count
            ],
            'orderBy'=>$orderBy,
            'filter'=>$options['filter']
        ];
        $firstResult = ($page-1)*$limit;

        return  [
            'data'=>$query->setFirstResult($firstResult)->setMaxResults($limit)->getResult(),
            'options'=>$options
        ];
    }



    /*
     * Список типов договоров
     * Договор строительного подряда - construction
     * договоры поставки - supply
     * Договор продажи - agreement
     */

    public function addСonstructionContract($arrKeyAttrib) {
        return $this->addContract($arrKeyAttrib,'construction');
    }

    public function addSupplyContract($arrKeyAttrib) {
        return $this->addContract($arrKeyAttrib,'supply');
    }

    public function addContract($arrKeyAttrib,$type) {

        $newContract = $this->loadNew($arrKeyAttrib);
        $newContract = $this->generateNumber($newContract);

        $newContract->setType($type);
        $newContract->setStartAt(new \DateTimeImmutable($arrKeyAttrib['start_at']));
        $newContract->setEndAt(new \DateTimeImmutable($arrKeyAttrib['end_at']));
        if (array_key_exists('credit_amount',$arrKeyAttrib) && $arrKeyAttrib['credit_amount'] && $arrKeyAttrib['credit_at_days']) {
            $newContract->setCreditDays($arrKeyAttrib['credit_at_days']);
            $newContract->setCredit($arrKeyAttrib['credit_amount']);
        }

        return $this->save($newContract);
    }

    private function generateNumber(Object $entity) {

        if (!property_exists($entity,'index')) {
            abort(500,'Для генерации номера необходимо поле index');
        }
        if (!property_exists($entity,'number')) {
            abort(500,'Для генерации номера необходимо поле index');
        }

        if (!property_exists($entity,'company')) {
            abort(500,'Для генерации номера необходимо поле company');
        }

        $qb = $this->em->createQueryBuilder()->setMaxResults(1);
        $qb = $qb->select('en')->from(get_class($entity),'en');
        $company = auth()->user()->getCompany();

        $qb = $qb->where($qb->expr()->eq('en.company',"?1"));
        $qb = $qb->andWhere($qb->expr()->between('en.createdAt','?2','?3'));
        $qb = $qb->orderBy('en.index','DESC');

        $query = $this->em->createQuery($qb->getDQL())->setMaxResults(1);

        $nowDate = new \DateTimeImmutable('now');

        $query->setParameter(1, $company->getId());
        $query->setParameter(2, $nowDate->modify('first day of January this year midnight'));
        $query->setParameter(3, $nowDate->modify('first day of January +1 year midnight'));

        if ($query->getResult()) {
            $result = $query->getSingleResult();
            $newIndex = $result->getIndex() + 1;
        } else {
            $newIndex = 1;
        }


        $newNumber= env('PREFIX_INVOICE_REQ','').$newIndex."/".$nowDate->format('Y');
        $entity->setIndex($newIndex);
        $entity->setNumberSys($newNumber);

        return $entity;
    }
    public function deleteByUuid($idContract)
    {
        $contract = $this->findMyCompnay($idContract);

        if ($contract->getInvoices()->count() > 0) {
            abort('500','Найдены поставки по договору, удаление невозможно');
        }
        if ($contract->getSpecifications()->count() > 0) {
            abort('500','Найдены связанные спецификации с договором, удаление невозможно');
        }

        return  parent::deleteByUuid($contract->getId());
    }

    public function listContractsSpec(Specification $specification,$options=[]){

                $options = $this->parseOptions($options);

                $qb = $this->em->createQueryBuilder();
        $qb = $qb->select('cntr')->from(Contracts::class,'cntr');
        $qb->join("cntr.specifications",'spec');

        $qb = $qb->where($qb->expr()->eq('cntr.company',"?1"));
        $qb = $qb->andWhere($qb->expr()->eq('spec.id',"?2"));



        if (array_key_exists('orderBy',$options) && $options['orderBy'] != []) {
            foreach ($options['orderBy'] as $key => $value) {
                $qb->orderBy("cntr.".$key,$value);
            }

        }
        $query = $this->em->createQuery($qb->getDQL());

        $nowDate = new \DateTimeImmutable('now');
        $company = auth()->user()->getCompany();
        $query->setParameter(1, $company->getId());
        $query->setParameter(2, $specification->getId());

        //dd($query->getDQL(),$query->getResult());
        return $this->_options($query,$options);

    }

    public function removeSpecificationContract(Contracts $contract, Specification $specification) {

        if (!$contract->getSpecifications()->contains($specification)) {
            return $contract;
        }

        if ($specification->getFixed() === true) {
           // abort(500,'Фиксированная спецификация');
        }
        $contract->removeSpecification($specification);
        $specification->removeContract($contract);
        $this->em->persist($contract);
        $this->em->persist($specification);
        $this->em->flush();
        return $contract;
    }
    public function addSpecificationContract(Contracts $contract, Specification $specification)
    {
        if ($contract->getSpecifications()->contains($specification)) {
            return $contract->getSpecifications();
        }

        #TODO Определить типы договоров для привязки
        if ($contract->getType() !== 'construction') {
           // abort(500,'Договор не подряда');
        }
        if ($specification->getFixed() === true) {
          //  abort(500,'Фиксированная спецификация');
        }

        $contract->addSpecification($specification);
        $specification->addContract($contract);
        $this->em->persist($contract);
        $this->em->persist($specification);
        $this->em->flush();


        return $contract->getSpecifications();
    }

    public function listSpecificationContract(Contracts $contract,$options)
    {
        return $contract->getSpecifications();
    }
}
